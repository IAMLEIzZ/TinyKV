# Raft 论文中文翻译

## 概述

共识算法使得一组机器能够作为一个协调的群体工作，即使其中部分成员发生故障，系统仍能正常运行。因此，共识算法在构建可靠的大规模软件系统中扮演着关键角色。在过去的十年中，Paxos 主导了共识算法的讨论：大多数共识算法的实现要么基于 Paxos，要么受到它的影响，Paxos 也成为了教授学生共识算法的主要工具。

然而，尽管有许多尝试使 Paxos 更易于理解，但它仍然非常难以掌握。此外，Paxos 的架构需要复杂的修改才能支持实际系统。因此，系统构建者和学生都在 Paxos 上遇到了困难。

在我们自己与 Paxos 的挣扎之后，我们开始寻找一种新的共识算法，希望为系统构建和教育提供更好的基础。我们的方法与众不同，因为我们的主要目标是**可理解性**：我们能否为实际系统定义一种共识算法，并以比 Paxos 更易于学习的方式描述它？此外，我们希望这种算法能够帮助系统构建者培养必要的直觉。算法不仅要能工作，还要让人明白它为什么能工作。

这项工作的成果是一种名为 **Raft** 的共识算法。在设计 Raft 时，我们应用了特定的技术来提高可理解性，包括**分解**（Raft 将领导者选举、日志复制和安全性分开）和**状态空间缩减**（与 Paxos 相比，Raft 减少了非确定性和服务器之间不一致的可能性）。一项针对两所大学 43 名学生的用户研究表明，Raft 比 Paxos 显著更容易理解：在学习两种算法后，其中 33 名学生能够更好地回答关于 Raft 的问题，而不是关于 Paxos 的问题。

Raft 在许多方面与现有的共识算法相似（最显著的是 Oki 和 Liskov 的 Viewstamped Replication），但它有几个新颖的特性：

- **强领导者**：Raft 使用比其他共识算法更强的领导形式。例如，日志条目只能从领导者流向其他服务器。这简化了复制日志的管理，并使 Raft 更易于理解。
- **领导者选举**：Raft 使用随机计时器来选举领导者。这只是在任何共识算法所需的心跳机制上增加了一小部分机制，同时能够简单快速地解决冲突。
- **成员变更**：Raft 的集群成员变更机制采用了一种新的联合共识方法，在过渡期间，两种不同配置的多数派会重叠。这使得集群在配置变更期间能够继续正常运行。

我们相信，Raft 在教育目的和作为实现基础方面都优于 Paxos 和其他共识算法。它比其他算法更简单、更易于理解；它的描述足够完整，能够满足实际系统的需求；它有多个开源实现，并被多家公司使用；其安全性已被形式化定义和证明；其效率与其他算法相当。

论文的其余部分介绍了复制状态机问题（第 2 节），讨论了 Paxos 的优点和缺点（第 3 节），描述了我们提高可理解性的一般方法（第 4 节），介绍了 Raft 共识算法（第 5-8 节），评估了 Raft（第 9 节），并讨论了相关工作（第 10 节）。

## 复制状态机

共识算法通常出现在复制状态机的上下文中。在这种方法中，一组服务器上的状态机计算相同状态的副本，即使其中一些服务器出现故障，系统仍然能够继续运行。复制状态机用于解决分布式系统中的各种容错问题。例如，像 GFS 、HDFS 和 RAMCloud 等大规模系统，通常会使用一个独立的复制状态机来管理领导者选举，并存储必须在领导者崩溃时依然能够保留的配置信息。复制状态机的例子包括 Chubby 和 ZooKeeper。

复制状态机通常通过复制日志来实现，如图 1 所示。每个服务器存储一个日志，日志中包含一系列命令，状态机按顺序执行这些命令。每个日志包含相同的命令，且命令顺序一致，因此每个状态机处理相同的命令序列。由于状态机是确定性的，因此每个状态机计算出相同的状态和相同的输出序列。

保持复制日志一致性是共识算法的工作。服务器上的共识模块接收来自客户端的命令，并将其添加到日志中。它与其他服务器上的共识模块通信，以确保每个日志最终包含相同的请求，顺序一致，即使某些服务器出现故障。一旦命令被正确复制，每个服务器的状态机按日志顺序处理命令，并将结果返回给客户端。因此，这些服务器表现得像一个单一的、具有高度可靠性的状态机。

实际系统中的共识算法通常具有以下特性：
• 在所有非拜占庭条件下（包括网络延迟、分区、丢包、重复和重新排序），它们能够确保安全性（永远不会返回错误的结果）。
• 只要任意大多数服务器能够正常工作并与彼此以及客户端进行通信，它们就能保持完全功能性（可用性）。因此，典型的五台服务器的集群能够容忍任何两台服务器的故障。假设服务器通过停止的方式失败，它们可能会从稳定存储中恢复状态并重新加入集群。
• 它们不依赖于时间来确保日志的一致性：故障时钟和极端的消息延迟最多会导致可用性问题。
• 在常见情况下，命令可以在集群中大多数服务器响应一次远程过程调用后就完成；即使少数慢速服务器也不会影响整个系统的性能。

## Paxos 的缺点

在过去的十年里，Leslie Lamport 的 Paxos 协议几乎成为了共识的代名词：它是最常在课程中讲解的协议，也是大多数共识实现的起点。Paxos 首先定义了一个能够就单一决策（如单个复制日志条目）达成一致的协议。我们称这一子集为单决策 Paxos。然后，Paxos 通过结合多个单决策协议实例，来促成一系列的决策，如一个日志（即多决策 Paxos）。Paxos 确保了安全性和活跃性，并支持集群成员变更。其正确性已经得到了证明，并且在正常情况下，它的效率是高的。

然而，Paxos 有两个显著的缺点。

第一个缺点：理解困难

Paxos 异常难以理解。Paxos 的完整解释以其晦涩难懂著称；很少有人能够理解它，而且通常需要付出很大努力。因此，出现了几种尝试用更简单的方式解释 Paxos 的尝试。这些解释主要集中在单决策子集上，但即使如此，它们依然难以理解。在 2012 年 NSDI 的非正式调查中，我们发现即使是在经验丰富的研究人员中，也很少有人能完全理解 Paxos。

我们自己也在理解 Paxos 方面遇到了困难；直到我们阅读了几篇简化的解释并设计了我们自己的替代协议，才最终理解了完整的协议，这个过程几乎花费了我们一年的时间。

我们假设 Paxos 的晦涩难懂来自于它选择将单决策子集作为基础。单决策 Paxos 非常复杂且微妙：它分为两个阶段，这两个阶段没有简单直观的解释，且无法独立理解。因此，我们很难形成直观的理解，搞清楚为什么单决策协议能够工作。多决策 Paxos 的组合规则增加了更多的复杂性和微妙性。我们认为，达成多个决策共识（即处理一个日志而不是单个条目）的问题，可以通过更直接、更显而易见的方式来分解。

第二个缺点：无法为实际实现提供良好的基础

Paxos 的第二个问题是它并未为实际实现提供一个良好的基础。一个原因是目前没有公认的多决策 Paxos 算法。Lamport 的描述大多集中在单决策 Paxos 上，他仅简要提到过多决策 Paxos 的可能方法，但许多细节并没有涉及。为了填补这些空白并优化 Paxos，出现了多个尝试，但这些方案彼此不同，也与 Lamport 的草图存在差异。一些系统，如 Chubby，实现了类似 Paxos 的算法，但大多数情况下，它们的细节并没有被公开。

此外，Paxos 的架构并不适合构建实际的系统；这也是单决策分解的另一个后果。例如，独立选择一组日志条目然后将它们合并成一个顺序日志并没有太大好处，这只会增加复杂性。围绕日志设计一个系统，其中新条目按顺序追加到日志中的方式更简单、更高效。另一个问题是，Paxos 在其核心使用了对等对等的对等网络方法（尽管最终提出了弱领导形式作为性能优化）。在一个只有一个决策的简化世界里，这种方法是有道理的，但很少有实际系统采用这种方法。如果必须做出一系列决策，首先选举一个领导者，然后让领导者协调决策，会更简单、更快速。

因此，实际系统与 Paxos 几乎没有什么相似之处。每个实现都以 Paxos 为起点，发现了实现它的困难后，最终发展出了完全不同的架构。这既耗时又容易出错，而理解 Paxos 的困难加剧了这个问题。Paxos 的公式可能对于证明其正确性很有用，但实际实现与 Paxos 的差异如此之大，以至于这些证明几乎没有价值。以下是 Chubby 实现者的典型评论：

    “Paxos算法的描述与实际系统的需求之间存在显著差距……最终的系统将基于一个未经验证的协议。”

由于这些问题，我们得出结论：Paxos 既不为系统构建提供良好的基础，也不适合教育。鉴于共识在大规模软件系统中的重要性，我们决定尝试设计一种替代的共识算法，具有比 Paxos 更好的属性。Raft 协议便是这一实验的结果。

## 为可理解性设计

在设计 Raft 时，我们有几个目标：它必须为系统构建提供一个完整且实用的基础，这样就能显著减少开发人员所需的设计工作；它必须在所有条件下保证安全性，并在典型操作条件下保持可用性；它必须对常见操作高效。然而，我们最重要的目标——也是最困难的挑战——是可理解性。必须确保一个大规模的受众能够轻松理解该算法。此外，还必须能够对算法形成直觉，以便系统构建者能够做出在实际系统实现中不可避免的扩展。

在 Raft 的设计过程中，有许多地方我们需要在不同的方案之间做出选择。在这些情况下，我们依据可理解性来评估各个备选方案：每个备选方案有多难以解释（例如，它的状态空间有多复杂，是否有微妙的含义？），以及读者是否容易完全理解该方法及其影响？

我们认识到这种分析中存在较高的主观性；尽管如此，我们采用了两种通常适用的技术。第一种技术是广为人知的问题分解法：在可能的情况下，我们将问题分解为独立的部分，这些部分可以相对独立地解决、解释和理解。例如，在 Raft 中，我们将领导者选举、日志复制、安全性和成员变更分开处理。

第二种方法是通过减少需要考虑的状态数量来简化状态空间，使系统更加连贯，并尽可能消除非确定性。具体来说，Raft 不允许日志中出现空洞，并限制了日志彼此之间不一致的方式。尽管在大多数情况下我们尽力消除非确定性，但在某些情况下，非确定性实际上可以提高可理解性。特别地，随机化方法引入了非确定性，但它们倾向于通过以相似的方式处理所有可能的选择（“选择任何一个；没关系”）来减少状态空间。我们使用随机化来简化 Raft 的领导者选举算法。

## Raft 共识算法

Raft 是一种管理复制日志的算法，如第 2 节所述。图 2 简要总结了该算法的精简版本以供参考，图 3 列出了该算法的关键属性；这些图中的元素将在本节的后续部分逐步讨论。

Raft 通过首先选举一个特殊的领导者，然后赋予该领导者完全的复制日志管理责任来实现共识。领导者接受来自客户端的日志条目，将它们复制到其他服务器，并告知服务器何时可以安全地将日志条目应用于其状态机。拥有领导者简化了复制日志的管理。例如，领导者可以决定将新条目放置在日志中的位置，而无需与其他服务器协商，数据也以简单的方式从领导者流向其他服务器。领导者可能会失败或与其他服务器断开连接，在这种情况下，必须选举一个新的领导者。

鉴于采用领导者的方法，Raft 将共识问题分解为三个相对独立的子问题，接下来的小节将讨论这些问题：
• 领导者选举：当现有领导者失败时，必须选举一个新的领导者（第 5.2 节）。
• 日志复制：领导者必须接受来自客户端的日志条目并将它们复制到集群中的其他服务器，强制其他日志与领导者的日志保持一致（第 5.3 节）。
• 安全性：Raft 的关键安全性属性是图 3 中的状态机安全性属性：如果任何服务器已经将某个日志条目应用于其状态机，则其他任何服务器都不能应用同一日志索引的不同命令。第 5.4 节描述了 Raft 如何确保这一属性；其解决方案涉及对第 5.2 节中描述的选举机制的额外限制。

在介绍完共识算法后，本节还将讨论可用性问题以及时序在系统中的作用。
## 图 2
### 状态（State）
所有服务器上的持久状态

（在响应 RPC 之前会写入稳定存储）
	•	currentTerm: 服务器最近看到的任期号（初始化为 0，随时间单调递增）。
	•	votedFor: 在当前任期中投票支持的候选者 ID（如果没有投票，则为 null）。
	•	log[]: 日志条目；每个条目包含状态机的命令以及领导者接收该条目的任期号（第一个索引是 1）。

所有服务器上的易失状态
	•	commitIndex: 已提交的最高日志条目的索引（初始化为 0，随时间单调递增）。
	•	lastApplied: 已应用到状态机的最高日志条目的索引（初始化为 0，随时间单调递增）。

领导者上的易失状态

（在选举后重新初始化）
	•	nextIndex[]: 对于每个服务器，待发送到该服务器的下一个日志条目的索引（初始化为领导者最后日志条目索引 + 1）。
	•	matchIndex[]: 对于每个服务器，已知复制到该服务器的最高日志条目索引（初始化为 0，随时间单调递增）。

### AppendEntries RPC（追加条目 RPC）

由领导者调用以复制日志条目 (§5.3)；也用作心跳 (§5.2)。
	•	参数
	•	term: 领导者的任期号。
	•	leaderId: 以便跟随者可以重定向客户端。
	•	prevLogIndex: 新日志条目之前的日志条目的索引。
	•	prevLogTerm: prevLogIndex 的任期号。
	•	entries[]: 需要存储的日志条目（为空则表示心跳；为了提高效率，可能会一次发送多个）。
	•	leaderCommit: 领导者的已提交索引（commitIndex）。
	•	结果
	•	term: 当前任期号，以便领导者更新自己。
	•	success: 如果跟随者包含一个与 prevLogIndex 和 prevLogTerm 匹配的日志条目，则为 true。
	•	接收者实现
	1.	如果 term < currentTerm，回复 false (§5.1)。
	2.	如果日志中不存在与 prevLogIndex 和 prevLogTerm 匹配的条目，回复 false (§5.3)。
	3.	如果已存在的条目与新条目冲突（索引相同但内容不同），删除现有条目及其后的所有条目 (§5.3)。
	4.	将所有尚未在日志中的新条目附加到日志中。
	5.	如果 leaderCommit > commitIndex，将 commitIndex 更新为 leaderCommit 和新日志条目索引中的较小值 (§5.3)。

### RequestVote RPC（请求投票 RPC）

由候选者调用以发起选举 (§5.2)。
	•	参数
	•	term: 候选者的任期号。
	•	candidateId: 请求投票的候选者 ID。
	•	lastLogIndex: 候选者日志中的最后一个条目的索引。
	•	lastLogTerm: 候选者日志中的最后一个条目的任期号。
	•	结果
	•	term: 当前任期号，以便候选者更新自己。
	•	voteGranted: 如果候选者收到选票，则为 true。
	•	接收者实现
	1.	如果 term < currentTerm，回复 false (§5.1)。
	2.	如果 votedFor 为空或等于候选者 ID，并且候选者日志至少和接收者的日志一样新，则投票支持 (§5.2, §5.4)。

### 服务器规则（Rules for Servers）

所有服务器：
	•	如果 commitIndex > lastApplied：递增 lastApplied，将 log[lastApplied] 应用到状态机 (§5.3)。
	•	如果 RPC 请求或响应的任期号 T > currentTerm：设置 currentTerm = T，转换为跟随者状态 (§5.1)。

跟随者 (§5.2)：
	•	响应来自候选者和领导者的 RPC。
	•	如果选举超时期间没有接收到当前领导者的 AppendEntries RPC 或给候选者的投票请求，转换为候选者。

候选者 (§5.2)：
	•	转换为候选者时，开始选举：
	•	递增 currentTerm。
	•	为自己投票。
	•	重置选举超时计时器。
	•	向所有其他服务器发送 RequestVote RPC。
	•	如果收到大多数服务器的选票：成为领导者。
	•	如果从新的领导者收到 AppendEntries RPC：转换为跟随者。
	•	如果选举超时：开始新一轮选举。

领导者：
	•	在选举后：发送初始的空 AppendEntries RPCs（心跳）以防止超时；之后定期发送。
	•	如果从客户端收到命令：将命令追加到本地日志中，回复后应用到状态机 (§5.3)。
	•	如果 last log index ≥ nextIndex 对于某个跟随者：
	•	从 nextIndex 开始发送 AppendEntries RPCs，包含日志条目：
	•	如果成功：更新 nextIndex 和 matchIndex。
	•	如果失败（日志不一致）：递减 nextIndex 并重试 (§5.3)。
	•	如果存在 N，满足 N > commitIndex，且大多数 matchIndex[i] ≥ N，并且 log[N].term == currentTerm：
	•	设置 commitIndex = N (§5.3, §5.4)。

## 5.1 Raft 基础
一个 Raft 集群包含多个服务器；通常的数量是五个，这样系统可以容忍两个服务器的失败。

在任何给定时刻，每个服务器处于三种状态之一：领导者（leader）、跟随者（follower）或 候选者（candidate）。在正常操作中，系统中有且只有一个领导者，其他所有服务器都是跟随者。跟随者是被动的：它们不会主动发起请求，而是仅仅响应领导者和候选者的请求。领导者处理所有客户端请求（如果客户端联系到跟随者，跟随者会将其重定向到领导者）。第三种状态——候选者，用于选举新的领导者，如第 5.2 节所述。图 4 展示了这些状态及其转换；这些转换将在下文讨论。

Raft 将时间分为若干个任期（term），如图 5 所示。每个任期都有一个递增的整数编号。每个任期都以选举开始，候选者试图成为领导者（如第 5.2 节所述）。如果某个候选者赢得选举，它将成为该任期内的领导者。在某些情况下，选举结果可能会是平局。在这种情况下，任期内没有领导者，新的任期（新的选举）将很快开始。Raft 确保在任何给定的任期内，最多只有一个领导者。

不同的服务器可能在不同的时间观察到任期之间的转换，在某些情况下，某个服务器可能无法观察到选举或甚至整个任期。任期在 Raft 中充当逻辑时钟 [14]，并允许服务器检测过时的信息，如过时的领导者。每个服务器存储一个当前的任期编号，该编号随着时间单调增加。当前的任期编号会在服务器之间进行交换；如果一个服务器的当前任期编号小于另一个服务器的，则它会更新自己的当前任期编号为较大的值。如果一个候选者或领导者发现自己的任期编号过时，它会立即回到跟随者状态。如果服务器收到一个过时任期编号的请求，它会拒绝该请求。

Raft 服务器通过远程过程调用（RPC）进行通信，基本的共识算法仅需要两种类型的 RPC。RequestVote RPC 由候选者在选举期间发起（见第 5.2 节），AppendEntries RPC 由领导者发起，用于复制日志条目并提供心跳机制（见第 5.3 节）。第 7 节增加了第三种 RPC，用于在服务器之间传输快照。服务器会在未及时收到响应时重试 RPC，并且为了最佳性能，它们会并行发起 RPC。
