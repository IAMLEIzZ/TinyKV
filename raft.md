# Raft 论文中文翻译
## 概述
共识算法使得一组机器能够作为一个协调的群体工作，即使其中部分成员发生故障，系统仍能正常运行。因此，共识算法在构建可靠的大规模软件系统中扮演着关键角色。在过去的十年中，Paxos主导了共识算法的讨论：大多数共识算法的实现要么基于 Paxos，要么受到它的影响，Paxos 也成为了教授学生共识算法的主要工具。

然而，尽管有许多尝试使 Paxos 更易于理解，但它仍然非常难以掌握。此外，Paxos 的架构需要复杂的修改才能支持实际系统。因此，系统构建者和学生都在 Paxos 上遇到了困难。

在我们自己与 Paxos 的挣扎之后，我们开始寻找一种新的共识算法，希望为系统构建和教育提供更好的基础。我们的方法与众不同，因为我们的主要目标是**可理解性**：我们能否为实际系统定义一种共识算法，并以比 Paxos 更易于学习的方式描述它？此外，我们希望这种算法能够帮助系统构建者培养必要的直觉。算法不仅要能工作，还要让人明白它为什么能工作。

这项工作的成果是一种名为 **Raft** 的共识算法。在设计 Raft 时，我们应用了特定的技术来提高可理解性，包括**分解**（Raft 将领导者选举、日志复制和安全性分开）和**状态空间缩减**（与 Paxos 相比，Raft 减少了非确定性和服务器之间不一致的可能性）。一项针对两所大学 43 名学生的用户研究表明，Raft 比 Paxos 显著更容易理解：在学习两种算法后，其中 33 名学生能够更好地回答关于 Raft 的问题，而不是关于 Paxos 的问题。

Raft 在许多方面与现有的共识算法相似（最显著的是 Oki 和 Liskov 的 Viewstamped Replication），但它有几个新颖的特性：

- **强领导者**：Raft 使用比其他共识算法更强的领导形式。例如，日志条目只能从领导者流向其他服务器。这简化了复制日志的管理，并使 Raft 更易于理解。
- **领导者选举**：Raft 使用随机计时器来选举领导者。这只是在任何共识算法所需的心跳机制上增加了一小部分机制，同时能够简单快速地解决冲突。
- **成员变更**：Raft 的集群成员变更机制采用了一种新的联合共识方法，在过渡期间，两种不同配置的多数派会重叠。这使得集群在配置变更期间能够继续正常运行。

我们相信，Raft 在教育目的和作为实现基础方面都优于 Paxos 和其他共识算法。它比其他算法更简单、更易于理解；它的描述足够完整，能够满足实际系统的需求；它有多个开源实现，并被多家公司使用；其安全性已被形式化定义和证明；其效率与其他算法相当。

论文的其余部分介绍了复制状态机问题（第 2 节），讨论了 Paxos 的优点和缺点（第 3 节），描述了我们提高可理解性的一般方法（第 4 节），介绍了 Raft 共识算法（第 5-8 节），评估了 Raft（第 9 节），并讨论了相关工作（第 10 节）。

## 复制状态机
共识算法通常出现在复制状态机的上下文中。在这种方法中，一组服务器上的状态机计算相同状态的副本，即使其中一些服务器出现故障，系统仍然能够继续运行。复制状态机用于解决分布式系统中的各种容错问题。例如，像 GFS 、HDFS 和 RAMCloud 等大规模系统，通常会使用一个独立的复制状态机来管理领导者选举，并存储必须在领导者崩溃时依然能够保留的配置信息。复制状态机的例子包括 Chubby 和 ZooKeeper。

复制状态机通常通过复制日志来实现，如图 1 所示。每个服务器存储一个日志，日志中包含一系列命令，状态机按顺序执行这些命令。每个日志包含相同的命令，且命令顺序一致，因此每个状态机处理相同的命令序列。由于状态机是确定性的，因此每个状态机计算出相同的状态和相同的输出序列。

保持复制日志一致性是共识算法的工作。服务器上的共识模块接收来自客户端的命令，并将其添加到日志中。它与其他服务器上的共识模块通信，以确保每个日志最终包含相同的请求，顺序一致，即使某些服务器出现故障。一旦命令被正确复制，每个服务器的状态机按日志顺序处理命令，并将结果返回给客户端。因此，这些服务器表现得像一个单一的、具有高度可靠性的状态机。

实际系统中的共识算法通常具有以下特性：
	•   在所有非拜占庭条件下（包括网络延迟、分区、丢包、重复和重新排序），它们能够确保安全性（永远不会返回错误的结果）。
	•	只要任意大多数服务器能够正常工作并与彼此以及客户端进行通信，它们就能保持完全功能性（可用性）。因此，典型的五台服务器的集群能够容忍任何两台服务器的故障。假设服务器通过停止的方式失败，它们可能会从稳定存储中恢复状态并重新加入集群。
	•	它们不依赖于时间来确保日志的一致性：故障时钟和极端的消息延迟最多会导致可用性问题。
	•	在常见情况下，命令可以在集群中大多数服务器响应一次远程过程调用后就完成；即使少数慢速服务器也不会影响整个系统的性能。

## Paxos的缺点
在过去的十年里，Leslie Lamport的Paxos协议几乎成为了共识的代名词：它是最常在课程中讲解的协议，也是大多数共识实现的起点。Paxos首先定义了一个能够就单一决策（如单个复制日志条目）达成一致的协议。我们称这一子集为单决策Paxos。然后，Paxos通过结合多个单决策协议实例，来促成一系列的决策，如一个日志（即多决策Paxos）。Paxos确保了安全性和活跃性，并支持集群成员变更。其正确性已经得到了证明，并且在正常情况下，它的效率是高的。

然而，Paxos有两个显著的缺点。

第一个缺点：理解困难

Paxos异常难以理解。Paxos的完整解释以其晦涩难懂著称；很少有人能够理解它，而且通常需要付出很大努力。因此，出现了几种尝试用更简单的方式解释Paxos的尝试。这些解释主要集中在单决策子集上，但即使如此，它们依然难以理解。在2012年NSDI的非正式调查中，我们发现即使是在经验丰富的研究人员中，也很少有人能完全理解Paxos。

我们自己也在理解Paxos方面遇到了困难；直到我们阅读了几篇简化的解释并设计了我们自己的替代协议，才最终理解了完整的协议，这个过程几乎花费了我们一年的时间。

我们假设Paxos的晦涩难懂来自于它选择将单决策子集作为基础。单决策Paxos非常复杂且微妙：它分为两个阶段，这两个阶段没有简单直观的解释，且无法独立理解。因此，我们很难形成直观的理解，搞清楚为什么单决策协议能够工作。多决策Paxos的组合规则增加了更多的复杂性和微妙性。我们认为，达成多个决策共识（即处理一个日志而不是单个条目）的问题，可以通过更直接、更显而易见的方式来分解。

第二个缺点：无法为实际实现提供良好的基础

Paxos的第二个问题是它并未为实际实现提供一个良好的基础。一个原因是目前没有公认的多决策Paxos算法。Lamport的描述大多集中在单决策Paxos上，他仅简要提到过多决策Paxos的可能方法，但许多细节并没有涉及。为了填补这些空白并优化Paxos，出现了多个尝试，但这些方案彼此不同，也与Lamport的草图存在差异。一些系统，如Chubby，实现了类似Paxos的算法，但大多数情况下，它们的细节并没有被公开。

此外，Paxos的架构并不适合构建实际的系统；这也是单决策分解的另一个后果。例如，独立选择一组日志条目然后将它们合并成一个顺序日志并没有太大好处，这只会增加复杂性。围绕日志设计一个系统，其中新条目按顺序追加到日志中的方式更简单、更高效。另一个问题是，Paxos在其核心使用了对等对等的对等网络方法（尽管最终提出了弱领导形式作为性能优化）。在一个只有一个决策的简化世界里，这种方法是有道理的，但很少有实际系统采用这种方法。如果必须做出一系列决策，首先选举一个领导者，然后让领导者协调决策，会更简单、更快速。

因此，实际系统与Paxos几乎没有什么相似之处。每个实现都以Paxos为起点，发现了实现它的困难后，最终发展出了完全不同的架构。这既耗时又容易出错，而理解Paxos的困难加剧了这个问题。Paxos的公式可能对于证明其正确性很有用，但实际实现与Paxos的差异如此之大，以至于这些证明几乎没有价值。以下是Chubby实现者的典型评论：

	“Paxos算法的描述与实际系统的需求之间存在显著差距……最终的系统将基于一个未经验证的协议。”

由于这些问题，我们得出结论：Paxos既不为系统构建提供良好的基础，也不适合教育。鉴于共识在大规模软件系统中的重要性，我们决定尝试设计一种替代的共识算法，具有比Paxos更好的属性。Raft协议便是这一实验的结果。

## 为可理解性设计
在设计Raft时，我们有几个目标：它必须为系统构建提供一个完整且实用的基础，这样就能显著减少开发人员所需的设计工作；它必须在所有条件下保证安全性，并在典型操作条件下保持可用性；它必须对常见操作高效。然而，我们最重要的目标——也是最困难的挑战——是可理解性。必须确保一个大规模的受众能够轻松理解该算法。此外，还必须能够对算法形成直觉，以便系统构建者能够做出在实际系统实现中不可避免的扩展。

在Raft的设计过程中，有许多地方我们需要在不同的方案之间做出选择。在这些情况下，我们依据可理解性来评估各个备选方案：每个备选方案有多难以解释（例如，它的状态空间有多复杂，是否有微妙的含义？），以及读者是否容易完全理解该方法及其影响？

我们认识到这种分析中存在较高的主观性；尽管如此，我们采用了两种通常适用的技术。第一种技术是广为人知的问题分解法：在可能的情况下，我们将问题分解为独立的部分，这些部分可以相对独立地解决、解释和理解。例如，在Raft中，我们将领导者选举、日志复制、安全性和成员变更分开处理。

第二种方法是通过减少需要考虑的状态数量来简化状态空间，使系统更加连贯，并尽可能消除非确定性。具体来说，Raft不允许日志中出现空洞，并限制了日志彼此之间不一致的方式。尽管在大多数情况下我们尽力消除非确定性，但在某些情况下，非确定性实际上可以提高可理解性。特别地，随机化方法引入了非确定性，但它们倾向于通过以相似的方式处理所有可能的选择（“选择任何一个；没关系”）来减少状态空间。我们使用随机化来简化Raft的领导者选举算法。

## Raft 共识算法
Raft是一种管理复制日志的算法，如第2节所述。图2简要总结了该算法的精简版本以供参考，图3列出了该算法的关键属性；这些图中的元素将在本节的后续部分逐步讨论。

Raft通过首先选举一个特殊的领导者，然后赋予该领导者完全的复制日志管理责任来实现共识。领导者接受来自客户端的日志条目，将它们复制到其他服务器，并告知服务器何时可以安全地将日志条目应用于其状态机。拥有领导者简化了复制日志的管理。例如，领导者可以决定将新条目放置在日志中的位置，而无需与其他服务器协商，数据也以简单的方式从领导者流向其他服务器。领导者可能会失败或与其他服务器断开连接，在这种情况下，必须选举一个新的领导者。

鉴于采用领导者的方法，Raft将共识问题分解为三个相对独立的子问题，接下来的小节将讨论这些问题：
	•	领导者选举：当现有领导者失败时，必须选举一个新的领导者（第5.2节）。
	•	日志复制：领导者必须接受来自客户端的日志条目并将它们复制到集群中的其他服务器，强制其他日志与领导者的日志保持一致（第5.3节）。
	•	安全性：Raft的关键安全性属性是图3中的状态机安全性属性：如果任何服务器已经将某个日志条目应用于其状态机，则其他任何服务器都不能应用同一日志索引的不同命令。第5.4节描述了Raft如何确保这一属性；其解决方案涉及对第5.2节中描述的选举机制的额外限制。

在介绍完共识算法后，本节还将讨论可用性问题以及时序在系统中的作用。
## 