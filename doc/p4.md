# 项目 4：事务

在前面的项目中，你已经构建了一个使用 Raft 的键/值数据库，确保多个节点之间的一致性。为了真正实现可扩展性，数据库必须能够处理多个客户端。当有多个客户端时，会出现一个问题：如果两个客户端尝试“同时”写入同一个键会发生什么？如果一个客户端写入后立即读取该键，他们是否应该期望读取的值与写入的值相同？在项目 4 中，你将通过在我们的数据库中构建一个事务系统来解决这些问题。

事务系统将是客户端（TinySQL）和服务器（TinyKV）之间的协作协议。双方必须正确实现，才能确保事务属性。我们将有一个完整的事务请求 API，独立于你在项目 1 中实现的原始请求（事实上，如果客户端同时使用原始 API 和事务 API，我们无法保证事务属性）。

事务承诺[*快照隔离*（SI）](https://en.wikipedia.org/wiki/Snapshot_isolation)。这意味着在事务中，客户端将从数据库中读取数据，就像数据库在事务开始时被冻结一样（事务看到数据库的*一致*视图）。要么事务的所有内容都写入数据库，要么都不写入（如果它与另一个事务冲突）。

为了提供 SI，你需要改变数据在底层存储中的存储方式。你不再为每个键存储一个值，而是为键和时间（由时间戳表示）存储一个值。这称为多版本并发控制（MVCC），因为每个键存储了多个不同版本的值。

你将在 A 部分实现 MVCC。在 B 和 C 部分，你将实现事务 API。

## TinyKV 中的事务

TinyKV 的事务设计遵循 [Percolator](https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36726.pdf)；它是一个两阶段提交协议（2PC）。

事务是一系列读写操作的列表。事务有一个开始时间戳，当事务提交时，它有一个提交时间戳（必须大于开始时间戳）。整个事务从开始时间戳有效的键版本中读取数据。提交后，所有写入操作看起来都是在提交时间戳写入的。任何要写入的键在开始时间戳和提交时间戳之间不能被其他事务写入，否则整个事务将被取消（这称为写冲突）。

协议从客户端从 TinyScheduler 获取开始时间戳开始。然后它在本地构建事务，从数据库中读取数据（使用包含开始时间戳的 `KvGet` 或 `KvScan` 请求，与 `RawGet` 或 `RawScan` 请求不同），但只在内存中记录写入操作。一旦事务构建完成，客户端将选择一个键作为*主键*（注意，这与 SQL 主键无关）。客户端向 TinyKV 发送 `KvPrewrite` 消息。`KvPrewrite` 消息包含事务中的所有写入操作。TinyKV 服务器将尝试锁定事务所需的所有键。如果锁定任何键失败，则 TinyKV 会向客户端响应事务失败。客户端可以稍后重试事务（即使用不同的开始时间戳）。如果所有键都被锁定，预写操作成功。每个锁存储事务的主键和生存时间（TTL）。

事实上，由于事务中的键可能分布在多个区域，因此存储在不同的 Raft 组中，客户端将发送多个 `KvPrewrite` 请求，每个请求发送到每个区域的领导者。每个预写请求仅包含该区域的修改。如果所有预写请求都成功，则客户端将发送包含主键的区域的提交请求。提交请求将包含一个提交时间戳（客户端也从 TinyScheduler 获取），这是事务写入提交的时间，从而使其他事务可见。

如果任何预写请求失败，则客户端通过向所有区域发送 `KvBatchRollback` 请求来回滚事务（以解锁事务中的所有键并删除任何预写的值）。

在 TinyKV 中，TTL 检查不会自发进行。要启动超时检查，客户端将当前时间发送到 TinyKV 的 `KvCheckTxnStatus` 请求中。该请求通过主键和开始时间戳来标识事务。锁可能丢失或已经提交；如果没有，TinyKV 将锁的 TTL 与 `KvCheckTxnStatus` 请求中的时间戳进行比较。如果锁已超时，则 TinyKV 回滚锁。无论如何，TinyKV 会响应锁的状态，以便客户端可以通过发送 `KvResolveLock` 请求采取行动。客户端通常在由于另一个事务的锁而无法预写事务时检查事务状态。

如果主键提交成功，则客户端将提交其他区域中的所有其他键。这些请求应该总是成功，因为通过响应预写请求，服务器承诺如果它收到该事务的提交请求，它将成功。一旦客户端收到所有预写响应，事务失败的唯一方式就是超时，而在这种情况下，提交主键应该失败。一旦主键提交，其他键就不能再超时。

如果主键提交失败，则客户端将通过发送 `KvBatchRollback` 请求回滚事务。

## A 部分

你在早期项目中实现的原始 API 将用户键和值直接映射到底层存储（Badger）中的键和值。由于 Badger 不知道分布式事务层，你必须在 TinyKV 中处理事务，并将用户键和值*编码*到底层存储中。这是通过多版本并发控制（MVCC）实现的。在本项目中，你将在 TinyKV 中实现 MVCC 层。

实现 MVCC 意味着使用简单的键/值 API 来表示事务 API。TinyKV 不再为每个键存储一个值，而是为每个键存储每个版本的值。例如，如果一个键的值为 `10`，然后被设置为 `20`，TinyKV 将存储这两个值（`10` 和 `20`）以及它们有效的时间戳。

TinyKV 使用三个列族（CF）：`default` 用于保存用户值，`lock` 用于存储锁，`write` 用于记录更改。`lock` CF 使用用户键访问；它存储一个序列化的 `Lock` 数据结构（定义在 [lock.go](/kv/transaction/mvcc/lock.go) 中）。`default` CF 使用用户键和写入事务的*开始*时间戳访问；它仅存储用户值。`write` CF 使用用户键和写入事务的*提交*时间戳访问；它存储一个 `Write` 数据结构（定义在 [write.go](/kv/transaction/mvcc/write.go) 中）。

用户键和时间戳组合成一个*编码键*。键的编码方式使得编码键的升序首先按用户键（升序）排序，然后按时间戳（降序）排序。这确保了对编码键的迭代将首先给出最新版本。编码和解码键的辅助函数定义在 [transaction.go](/kv/transaction/mvcc/transaction.go) 中。

本练习需要实现一个名为 `MvccTxn` 的结构体。在 B 和 C 部分，你将使用 `MvccTxn` API 来实现事务 API。`MvccTxn` 提供了基于用户键和锁、写入和值的逻辑表示的读写操作。修改在 `MvccTxn` 中收集，一旦命令的所有修改都收集完毕，它们将一次性写入底层数据库。这确保了命令的原子性成功或失败。请注意，MVCC 事务与 TinySQL 事务不同。MVCC 事务包含单个命令的修改，而不是一系列命令。

`MvccTxn` 定义在 [transaction.go](/kv/transaction/mvcc/transaction.go) 中。有一个存根实现和一些用于编码和解码键的辅助函数。测试在 [transaction_test.go](/kv/transaction/mvcc/transaction_test.go) 中。对于本练习，你应该实现每个 `MvccTxn` 方法，以便所有测试通过。每个方法都记录了其预期行为。

> 提示：
>
> - `MvccTxn` 应该知道它表示的请求的开始时间戳。
> - 最有可能具有挑战性的方法是 `GetValue` 和检索写入的方法。你需要使用 `StorageReader` 来迭代 CF。记住编码键的排序，并记住在决定值是否有效时，取决于事务的提交时间戳，而不是开始时间戳。

## B 部分

在这一部分中，你将使用 A 部分的 `MvccTxn` 来实现 `KvGet`、`KvPrewrite` 和 `KvCommit` 请求的处理。如上所述，`KvGet` 从数据库中读取指定时间戳的值。如果在 `KvGet` 请求时，要读取的键被另一个事务锁定，则 TinyKV 应返回错误。否则，TinyKV 必须搜索键的版本以找到最近的有效值。

`KvPrewrite` 和 `KvCommit` 分两个阶段将值写入数据库。这两个请求都操作多个键，但实现可以独立处理每个键。

`KvPrewrite` 是实际将值写入数据库的地方。键被锁定并存储一个值。我们必须检查另一个事务是否没有锁定或写入相同的键。

`KvCommit` 不会改变数据库中的值，但它会记录值已提交。如果键未被锁定或被另一个事务锁定，`KvCommit` 将失败。

你需要实现 [server.go](/kv/server/server.go) 中定义的 `KvGet`、`KvPrewrite` 和 `KvCommit` 方法。每个方法都接受一个请求对象并返回一个响应对象，你可以通过查看 [kvrpcpb.proto](/proto/kvrpcpb.proto) 中的协议定义来查看这些对象的内容（你不应该需要更改协议定义）。

TinyKV 可以同时处理多个请求，因此可能存在本地竞争条件。例如，TinyKV 可能会同时收到来自不同客户端的两个请求，其中一个提交一个键，另一个回滚同一个键。为了避免竞争条件，你可以*锁定*数据库中的任何键。这个锁的工作方式类似于每个键的互斥锁。一个锁覆盖所有 CF。[latches.go](/kv/transaction/latches/latches.go) 定义了一个 `Latches` 对象，它提供了此功能的 API。

> 提示：
>
> - 所有命令都是事务的一部分。事务由开始时间戳（也称为开始版本）标识。
> - 任何请求都可能导致区域错误，这些错误应该以与原始请求相同的方式处理。大多数响应都有一种指示非致命错误的方式，例如键被锁定。通过向客户端报告这些错误，客户端可以在稍后重试事务。

## C 部分

在这一部分中，你将实现 `KvScan`、`KvCheckTxnStatus`、`KvBatchRollback` 和 `KvResolveLock`。从高层次来看，这与 B 部分类似 - 使用 `MvccTxn` 实现 [server.go](/kv/server/server.go) 中的 gRPC 请求处理程序。

`KvScan` 是 `RawScan` 的事务等效项，它从数据库中读取多个值。但与 `KvGet` 一样，它在单个时间点读取。由于 MVCC，`KvScan` 比 `RawScan` 复杂得多 - 由于多个版本和键编码，你不能依赖底层存储来迭代值。

`KvCheckTxnStatus`、`KvBatchRollback` 和 `KvResolveLock` 在客户端尝试写入事务时遇到某种冲突时使用。每个都涉及更改现有锁的状态。

`KvCheckTxnStatus` 检查超时，删除过期的锁并返回锁的状态。

`KvBatchRollback` 检查键是否被当前事务锁定，如果是，则删除锁，删除任何值，并留下回滚指示作为写入。

`KvResolveLock` 检查一批锁定的键，并回滚它们或提交它们。

> 提示：
>
> - 对于扫描，你可能会发现实现自己的扫描器（迭代器）抽象很有帮助，它迭代逻辑值，而不是底层存储中的原始值。`kv/transaction/mvcc/scanner.go` 是一个框架。
> - 在扫描时，某些错误可以记录为单个键的错误，不应导致整个扫描停止。对于其他命令，任何单个键导致的错误都应导致整个操作停止。
> - 由于 `KvResolveLock` 要么提交要么回滚其键，你应该能够与 `KvBatchRollback` 和 `KvCommit` 实现共享代码。
> - 时间戳由物理部分和逻辑部分组成。物理部分大致是单调的挂钟时间。通常，我们使用整个时间戳，例如在比较时间戳是否相等时。然而，在计算超时时，我们必须仅使用时间戳的物理部分。为此，你可能会发现 [transaction.go](/kv/transaction/mvcc/transaction.go) 中的 `PhysicalTime` 函数很有用。